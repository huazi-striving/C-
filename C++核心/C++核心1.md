# 内存分区模型

C++程序在执行时，将`内存`大方向划分为`4个区域`

- `代码区`：存放函数体的`二进制代码`，由`操作系统进行管理的`
- `全局区`：存放`全局变量`和`静态变量`以及`常量`
- `栈区`：由编译器`自动分配释放`, 存放函数的参数值,局部变量等
- `堆区`：由`程序员分配和释放`,若程序员不释放,`程序结束时由操作系统回收`

内存4区意义：

- 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程



## 1.程序运行前

在程序编译后，生成了`.exe`可执行程序，**未执行该程序前**分为两个区域:

- 代码区：
  - 存放 `CPU` 执行的机器指令
  - 代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
  - 代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令
- 全局区：
  - `全局变量`和`静态变量`存放在此
  - `全局区`还包含了`常量区`, 字符串`常量`和其他`常量`也存放在此
  - 该区域的数据在程序结束后由操作系统释放



总结：

- C++中在程序运行前分为`全局区`和`代码区`
- `代码区`特点是`共享`和`只读`
- `全局区`中存放`全局变量`、`静态变量`、`常量`
- `常量区`中存放 `const修饰的全局常量`  和 `字符串常量`等常量



## 2.程序运行后

栈区：

- 由`编译器`自动`分配释放`, 存放函数的参数值,局部变量等
- `栈区`开辟的数据由`编译器自动释放`

堆区：

- 由`程序员分配释放`,若`程序员不释放,程序结束时由操作系统回收`
- 在`C++`中主要利用`new`在`堆区开辟内存`

总结：

- `堆区`数据由`程序员管理开辟和释放`
- `堆区`数据利用`new`关键字进行开辟内存



## 3.`new`操作符开辟`堆区`

- `C++`中利用`new操作符`在堆区开辟数据
- `堆区开辟`的数据，由程序员`手动开辟，手动释放`，释放利用操作符 `delete`
- 利用`new`创建的数据，会`返回`该数据对应的`类型的指针`



~~~c++
#include<iostream>
using namespace std;

int main()
{
	int* p = new int(4);  // 分配并初始化一个int型，数值为4  
	cout << *p << endl;  //4

	*p = 10;               //修改值为10
	cout << *p << endl;   //10
    
    delete p;   //释放内存
	return 0;
}
~~~

~~~c++
#include<iostream>
using namespace std;

int main()
{
	int* arr = new int[10];   //分配10个空间的int数组
    
	for (int i = 0; i < 10; i++)
	{
		arr[i] = i * i;
	}
    
	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
    
	delete[] arr;   //释放数组需要在delete后加[]
	return 0;
}
~~~





